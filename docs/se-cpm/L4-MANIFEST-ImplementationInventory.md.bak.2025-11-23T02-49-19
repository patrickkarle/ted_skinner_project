# L4-MANIFEST: Implementation Inventory

**Document ID:** L4-MANIFEST-FULLINTEL-001
**Version:** 1.0
**Date:** 2025-11-19
**Parent:** L3-CDD-01 through L3-CDD-06
**Traceability:** Complete SE-CPM hierarchy (L0 → L1 → L2 → L3 → L4)

---

## 1. Manifest Overview

### 1.1 Purpose
Provides complete implementation inventory using taxonomy codes (IP-XXX for integration points, DT-XXX for data transformations, IM-XXXX for implementation items) to ensure 100% traceability from requirements to code.

### 1.2 Taxonomy Reference
- **IP-XXX**: Integration Points (API calls, IPC commands, database queries, file operations)
- **DT-XXX**: Data Transformations (validations, conversions, normalizations, serializations)
- **IM-XXXX**: Implementation Inventory (structs, functions, constants, tests, components)

### 1.3 Document Structure
This manifest follows the Continuum Development Process v4.4 requirement for continuous manifest maintenance throughout all phases as the "golden thread" of traceability.

---

## 2. Integration Points (IP-XXX)

### 2.1 Tauri IPC Integration (Frontend ↔ Backend)

#### IP-001: run_research Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → Rust backend
**Dependencies:** IM-1001 (AppState), IM-2001 (AgentOrchestrator)
**L3 Reference:** L3-CDD-06 SetupScreen.tsx, L2-ICD-01 Section 2.1
```rust
#[tauri::command]
async fn run_research(
    company: String,
    window: tauri::Window,
    state: tauri::State<'_, AppState>
) -> Result<ResearchResult, String>
```

#### IP-002: get_session_history Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → StateManager → SQLite
**Dependencies:** IM-5001 (StateManager), IM-5010 (get_session_history method)
**L3 Reference:** L3-CDD-06 SessionHistory.tsx, L2-ICD-01 Section 2.2
```rust
#[tauri::command]
async fn get_session_history(
    limit: Option<usize>,
    state: tauri::State<'_, AppState>
) -> Result<Vec<SessionSummary>, String>
```

#### IP-003: get_session_output Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → StateManager → SQLite
**Dependencies:** IM-5001 (StateManager), IM-5015 (get_session method)
**L3 Reference:** L3-CDD-06 ResultsViewer.tsx, L2-ICD-01 Section 2.3
```rust
#[tauri::command]
async fn get_session_output(
    session_id: String,
    state: tauri::State<'_, AppState>
) -> Result<String, String>
```

#### IP-004: export_to_pdf Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → File system
**Dependencies:** IM-5001 (StateManager), External: markdown-to-pdf crate
**L3 Reference:** L3-CDD-06 ResultsViewer.tsx, L2-ICD-01 Section 2.4

#### IP-005: copy_to_clipboard Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → System clipboard
**Dependencies:** IM-5015 (get_session method), External: clipboard crate
**L3 Reference:** L3-CDD-06 ResultsViewer.tsx, L2-ICD-01 Section 2.5

#### IP-006: save_api_keys Command
**Location:** `src-tauri/src/main.rs`
**Type:** Async Tauri command
**Data Flow:** Frontend → OS credential manager
**Dependencies:** IM-1002 (ApiKeyConfig), External: keyring crate
**L3 Reference:** L3-CDD-06 SettingsPanel.tsx, L2-ICD-01 Section 2.6

### 2.2 Event Emissions (Backend → Frontend)

#### IP-007: workflow_started Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Data Flow:** AgentOrchestrator → Frontend
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.1

#### IP-008: phase_started Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.2

#### IP-009: phase_progress Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.3

#### IP-010: phase_completed Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.4

#### IP-011: quality_gate_failed Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method), IM-4001 (QualityGateValidator)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.5

#### IP-012: workflow_completed Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.6

#### IP-013: workflow_error Event
**Location:** `src-tauri/src/agent.rs`
**Type:** Tauri event emission
**Dependencies:** IM-2020 (emit_progress method)
**L3 Reference:** L3-CDD-01 Section 5.6, L2-ICD-01 Section 3.7

### 2.3 External API Integration

#### IP-014: Anthropic Claude API
**Location:** `src-tauri/src/llm/providers/anthropic.rs`
**Type:** HTTP POST
**Endpoint:** `https://api.anthropic.com/v1/messages`
**Dependencies:** IM-3100 (AnthropicProvider), External: reqwest
**L3 Reference:** L3-CDD-03 Section 6.1

#### IP-015: Google Gemini API
**Location:** `src-tauri/src/llm/providers/gemini.rs`
**Type:** HTTP POST
**Endpoint:** `https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent`
**Dependencies:** IM-3110 (GeminiProvider), External: reqwest
**L3 Reference:** L3-CDD-03 Section 6.2

#### IP-016: DeepSeek API
**Location:** `src-tauri/src/llm/providers/deepseek.rs`
**Type:** HTTP POST
**Endpoint:** `https://api.deepseek.com/v1/chat/completions`
**Dependencies:** IM-3120 (DeepSeekProvider), External: reqwest
**L3 Reference:** L3-CDD-03 Section 6.3

#### IP-017: Tavily Search API
**Location:** `src-tauri/src/tools/tavily_search.rs`
**Type:** HTTP POST
**Endpoint:** `https://api.tavily.com/search`
**Dependencies:** IM-2110 (TavilySearchTool), External: reqwest
**L3 Reference:** L3-CDD-02 Section 6.2

#### IP-018: NewsAPI.org API
**Location:** `src-tauri/src/tools/newsapi_search.rs`
**Type:** HTTP GET
**Endpoint:** `https://newsapi.org/v2/everything`
**Dependencies:** IM-2120 (NewsAPISearchTool), External: reqwest
**L3 Reference:** L3-CDD-02 Section 6.3

### 2.4 Database Integration (SQLite)

#### IP-019: Create Session
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL INSERT
**Table:** sessions
**Dependencies:** IM-5020 (create_session method)
**L3 Reference:** L3-CDD-05 Section 5.3
```sql
INSERT INTO sessions (session_id, company, status, created_at, cost_usd)
VALUES (?1, ?2, ?3, ?4, ?5)
```

#### IP-020: Update Session Status
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL UPDATE
**Table:** sessions
**Dependencies:** IM-5021 (update_session_status method)
**L3 Reference:** L3-CDD-05 Section 5.3
```sql
UPDATE sessions
SET status = ?1, completed_at = ?2, error_message = ?3
WHERE session_id = ?4
```

#### IP-021: Save Phase Completion
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL INSERT
**Table:** phase_completions
**Dependencies:** IM-5030 (save_phase_completion method)
**L3 Reference:** L3-CDD-05 Section 5.4
```sql
INSERT OR REPLACE INTO phase_completions
(session_id, phase_id, completed_at, duration_ms, output, cost_usd)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
```

#### IP-022: Save Workflow Context
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL INSERT
**Table:** workflow_context
**Dependencies:** IM-5040 (save_context method)
**L3 Reference:** L3-CDD-05 Section 5.5
```sql
INSERT OR REPLACE INTO workflow_context
(session_id, context_json, last_updated)
VALUES (?1, ?2, ?3)
```

#### IP-023: Load Workflow Context
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL SELECT
**Table:** workflow_context
**Dependencies:** IM-5041 (load_context method)
**L3 Reference:** L3-CDD-05 Section 5.5
```sql
SELECT context_json FROM workflow_context WHERE session_id = ?
```

#### IP-024: Get Session History
**Location:** `src-tauri/src/state/mod.rs`
**Type:** SQL SELECT
**Table:** sessions
**Dependencies:** IM-5010 (get_session_history method)
**L3 Reference:** L3-CDD-05 Section 5.3
```sql
SELECT session_id, company, created_at, status, duration_ms, cost_usd
FROM sessions
ORDER BY created_at DESC
LIMIT ?
```

### 2.5 File System Integration

#### IP-025: Read Manifest YAML
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** File read + YAML parse
**Path:** `manifests/fullintel_process_manifest.yaml`
**Dependencies:** IM-1100 (ManifestParser), External: serde_yaml
**L3 Reference:** L3-CDD-01 Section 4.1

#### IP-026: Write PDF Export
**Location:** `src-tauri/src/export/pdf.rs`
**Type:** File write
**Path:** User-specified (default: Downloads/)
**Dependencies:** IP-004 (export_to_pdf command), External: markdown-pdf
**L3 Reference:** L2-ICD-01 Section 2.4

#### IP-027: SQLite Database File
**Location:** `src-tauri/src/state/mod.rs`
**Type:** File read/write
**Path:** `{app_data_dir}/fullintel.db`
**Dependencies:** IM-5001 (StateManager), External: rusqlite
**L3 Reference:** L3-CDD-05 Section 4

---

## 3. Data Transformations (DT-XXX)

### 3.1 Input Validation

#### DT-001: Company Name Validation
**Location:** Frontend `SetupScreen.tsx` + Backend `run_research` command
**Type:** String sanitization
**Rules:** Non-empty, max 200 chars, trim whitespace
**Dependencies:** IP-001
**L3 Reference:** L2-ICD-01 Section 7.1

#### DT-002: API Key Validation
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Format validation
**Rules:** Prefix-based validation per provider:
  - **Anthropic Claude:** `sk-ant-` (specific Claude prefix)
  - **Google Gemini:** `AIza` (Google API key prefix)
  - **DeepSeek:** `sk-` (generic OpenAI-compatible prefix, verified 2025-11-20)
  - **Fallback:** Accept any `sk-` prefix for OpenAI-compatible providers
**Validation Logic:**
  ```rust
  fn validate_api_key(provider: &str, key: &str) -> Result<(), ValidationError> {
      let is_valid = match provider {
          "anthropic" => key.starts_with("sk-ant-") && key.len() >= 50,
          "google" => key.starts_with("AIza") && key.len() >= 39,
          "deepseek" => key.starts_with("sk-") && key.len() >= 40,
          _ => false,
      };

      if is_valid {
          Ok(())
      } else {
          Err(ValidationError::InvalidApiKey(provider.to_string()))
      }
  }
  ```
**Dependencies:** IP-006 (save_api_keys)
**L3 Reference:** L2-ICD-01 Section 7.1

#### DT-003: Session ID Validation
**Location:** `src-tauri/src/main.rs`
**Type:** UUID format validation
**Rules:** Valid UUID v4 format
**Dependencies:** IP-002, IP-003, IP-004, IP-005
**L3 Reference:** L2-ICD-01 Section 7.1

### 3.2 Data Serialization/Deserialization

#### DT-004: LLMRequest Serialization
**Location:** `src-tauri/src/llm/types.rs`
**Type:** Rust struct → JSON
**Dependencies:** IM-3001 (LLMRequest), External: serde_json
**L3 Reference:** L3-CDD-03 Section 3.1
```rust
#[derive(Serialize, Deserialize)]
pub struct LLMRequest { /* fields */ }
```

#### DT-005: ResearchResult Serialization
**Location:** `src-tauri/src/types.rs`
**Type:** Rust struct → JSON → TypeScript
**Dependencies:** IP-001 (run_research return type)
**L3 Reference:** L2-ICD-01 Section 2.1

#### DT-006: PhaseCompletion Serialization
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust struct → JSON → SQLite TEXT
**Dependencies:** IP-021 (save_phase_completion)
**L3 Reference:** L3-CDD-05 Section 3.1

#### DT-007: WorkflowContext Serialization
**Location:** `src-tauri/src/state/mod.rs`
**Type:** HashMap<String, Value> → JSON string
**Dependencies:** IP-022 (save_context), IM-5040
**L3 Reference:** L3-CDD-05 Section 5.5

#### DT-008: Manifest YAML Deserialization
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** YAML file → ProcessManifest struct
**Dependencies:** IP-025, IM-1100 (ManifestParser)
**L3 Reference:** L3-CDD-01 Section 4.1

### 3.3 Data Transformations (Business Logic)

#### DT-009: LLM Response → CompanyProfile
**Location:** `src-tauri/src/agent.rs` (phase_1 execution)
**Type:** JSON string → Typed struct
**Dependencies:** IM-2010 (execute_phase), DT-010
**L3 Reference:** L2-ICD-02 Section 2.1
```rust
let profile: CompanyProfile = serde_json::from_str(&llm_response)?;
```

#### DT-010: CompanyProfile Validation
**Location:** `src-tauri/src/types.rs`
**Type:** Struct field validation
**Rules:** Non-empty company_name, valid revenue_tier enum
**Dependencies:** DT-009
**L3 Reference:** L2-ICD-02 Section 2.1

#### DT-011: LLM Response → SituationAnalysis
**Location:** `src-tauri/src/agent.rs` (phase_2 execution)
**Type:** JSON string → Typed struct
**Dependencies:** IM-2010 (execute_phase)
**L3 Reference:** L2-ICD-02 Section 2.2

#### DT-012: LLM Response → CommunicationsIntelligence
**Location:** `src-tauri/src/agent.rs` (phase_3 execution)
**Type:** JSON string → Typed struct
**Dependencies:** IM-2010 (execute_phase)
**L3 Reference:** L2-ICD-02 Section 2.3

#### DT-013: LLM Response → SolutionPackage
**Location:** `src-tauri/src/agent.rs` (phase_4 execution)
**Type:** JSON string → Typed struct
**Dependencies:** IM-2010 (execute_phase), DT-013A (scenario mapping)
**L3 Reference:** L2-ICD-02 Section 2.4

#### DT-013A: Scenario Type → Solution Package Mapping
**Location:** `src-tauri/src/agent.rs` (phase_4 logic map)
**Type:** Rule-based mapping (scenario_type → solution + case_study)
**Dependencies:** DT-011 (SituationAnalysis input)
**L3 Reference:** L2-ICD-02 Section 2.4, L0-REQ SR-002

**Mapping Table:**

| Scenario Type | Fullintel Solution Package | Typical Case Study | ROI Driver |
|--------------|---------------------------|-------------------|------------|
| **CRISIS** | Crisis Communications + Media Monitoring | Healthcare breach (48hr response, 87% sentiment recovery) | Reputation protection, stock price stabilization |
| **LAUNCH** | Product Launch + Analyst Relations | Tech IPO (250 media placements, 45% share of voice) | Market awareness, analyst coverage |
| **MA** | M&A Communications + Stakeholder Engagement | Enterprise merger ($2.3B deal, 92% approval) | Deal completion, regulatory approval |
| **REGULATORY** | Government Relations + Policy Advocacy | Financial services compliance (3-month timeline) | Penalty avoidance, regulatory approval |
| **COMPETITIVE** | Competitive Intelligence + Market Positioning | Market leader defense (32% share gain vs competitor) | Market share protection, differentiation |
| **EXECUTIVE** | Executive Positioning + Thought Leadership | C-suite transition (6-month visibility campaign) | Leadership credibility, investor confidence |

**Selection Algorithm:**
```rust
fn select_solution_package(scenario: &SituationAnalysis) -> SolutionPackage {
    match scenario.scenario_type.as_str() {
        "CRISIS" => SolutionPackage {
            primary_service: "Crisis Communications".to_string(),
            secondary_service: "Media Monitoring".to_string(),
            case_study: CaseStudy {
                client_name: "Major Healthcare Provider".to_string(),
                scenario: "Data breach affecting 2.1M patients".to_string(),
                solution: "48-hour crisis response, stakeholder communications".to_string(),
                results: "87% sentiment recovery in 14 days, full regulatory compliance".to_string(),
                timeframe: "2 weeks".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Reputation recovery speed".to_string(),
                baseline: "6-12 months industry average".to_string(),
                with_fullintel: "14 days to 87% recovery".to_string(),
                cost_savings: "Estimated $15M in lost business prevented".to_string(),
            },
        },

        "LAUNCH" => SolutionPackage {
            primary_service: "Product Launch Communications".to_string(),
            secondary_service: "Analyst Relations".to_string(),
            case_study: CaseStudy {
                client_name: "B2B SaaS Company (Pre-IPO)".to_string(),
                scenario: "Enterprise platform launch targeting Fortune 500".to_string(),
                solution: "6-month launch campaign, 45 analyst briefings".to_string(),
                results: "250 media placements, 45% share of voice, 3 Gartner mentions".to_string(),
                timeframe: "6 months".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Pipeline acceleration".to_string(),
                baseline: "12-18 month sales cycle".to_string(),
                with_fullintel: "Avg 8-month cycle (33% faster)".to_string(),
                cost_savings: "$2.3M in reduced CAC for first 100 enterprise customers".to_string(),
            },
        },

        "MA" => SolutionPackage {
            primary_service: "M&A Communications".to_string(),
            secondary_service: "Stakeholder Engagement".to_string(),
            case_study: CaseStudy {
                client_name: "Enterprise Software Acquirer".to_string(),
                scenario: "$2.3B acquisition requiring shareholder approval".to_string(),
                solution: "90-day stakeholder campaign, regulatory filings support".to_string(),
                results: "92% shareholder approval, zero activist opposition".to_string(),
                timeframe: "3 months".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Deal completion certainty".to_string(),
                baseline: "68% M&A completion rate (industry avg)".to_string(),
                with_fullintel: "92% approval achieved (top quartile)".to_string(),
                cost_savings: "Deal risk reduction valued at $50M+ (2% of deal value)".to_string(),
            },
        },

        "REGULATORY" => SolutionPackage {
            primary_service: "Government Relations".to_string(),
            secondary_service: "Policy Advocacy".to_string(),
            case_study: CaseStudy {
                client_name: "Regional Financial Institution".to_string(),
                scenario: "New state-level compliance requirements (Q1 2024)".to_string(),
                solution: "Legislative engagement, compliance communications".to_string(),
                results: "Favorable exemption for institutions <$10B AUM".to_string(),
                timeframe: "6 months (regulatory cycle)".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Compliance cost avoidance".to_string(),
                baseline: "$8.2M annual compliance burden (estimated)".to_string(),
                with_fullintel: "Exemption achieved, $0 new costs".to_string(),
                cost_savings: "$8.2M annual savings (ROI: 164x on $50K engagement)".to_string(),
            },
        },

        "COMPETITIVE" => SolutionPackage {
            primary_service: "Competitive Intelligence".to_string(),
            secondary_service: "Market Positioning".to_string(),
            case_study: CaseStudy {
                client_name: "Enterprise Cloud Provider".to_string(),
                scenario: "New competitor launch threatening 15% market share".to_string(),
                solution: "Competitive response, analyst re-education, customer retention".to_string(),
                results: "32% share gain vs competitor, 95% customer retention".to_string(),
                timeframe: "12 months".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Market share defense".to_string(),
                baseline: "15% share at risk ($45M ARR)".to_string(),
                with_fullintel: "32% share gain, $96M ARR protected/grown".to_string(),
                cost_savings: "$51M net revenue impact (vs projected loss)".to_string(),
            },
        },

        "EXECUTIVE" => SolutionPackage {
            primary_service: "Executive Positioning".to_string(),
            secondary_service: "Thought Leadership".to_string(),
            case_study: CaseStudy {
                client_name: "Fortune 500 Technology Company".to_string(),
                scenario: "New CEO transition, investor confidence critical".to_string(),
                solution: "6-month visibility campaign, investor roadshow support".to_string(),
                results: "34 media features, 12 conference keynotes, +8% stock price".to_string(),
                timeframe: "6 months".to_string(),
            },
            roi_projection: RoiProjection {
                metric: "Investor confidence (stock performance)".to_string(),
                baseline: "Industry avg -2% during CEO transition".to_string(),
                with_fullintel: "+8% stock appreciation (outperformance: +10%)".to_string(),
                cost_savings: "$340M market cap increase on $3.4B valuation".to_string(),
            },
        },

        _ => {
            // Fallback: Default to crisis package
            warn!("Unknown scenario type: {}. Defaulting to CRISIS package.", scenario.scenario_type);
            // ... return CRISIS package as safe default
        }
    }
}
```

**Validation Rules:**
- Every scenario type MUST map to exactly one primary + secondary service
- Every solution package MUST include specific case study (no generic placeholders)
- ROI projections MUST include quantified metrics (no "significant improvement")
- Case study client names anonymized but sector-specific

**Traceability:**
- **L0 SR-002:** Quality standardization - specific case studies 100% of briefs
- **L0 SR-002:** ROI calculations present 100% of briefs
- **L5 Tests:** Test case study selection for all 6 scenario types (IM-2010-T4 through T9)

#### DT-014: LLM Response → MarkdownBrief
**Location:** `src-tauri/src/agent.rs` (phase_5 execution)
**Type:** String (markdown format)
**Dependencies:** IM-2010 (execute_phase)
**L3 Reference:** L2-ICD-02 Section 2.5

#### DT-015: Token Count → Cost Calculation
**Location:** `src-tauri/src/llm/cost.rs`
**Type:** (prompt_tokens, completion_tokens, model) → USD
**Dependencies:** IM-3200 (calculate_cost function)
**L3 Reference:** L3-CDD-03 Section 8.1
```rust
cost_usd = (prompt_tokens * input_price / 1_000_000.0)
         + (completion_tokens * output_price / 1_000_000.0)
```

#### DT-016: Phase Duration Calculation
**Location:** `src-tauri/src/agent.rs`
**Type:** (start_time, end_time) → duration_ms
**Dependencies:** IM-2010 (execute_phase)
**L3 Reference:** L3-CDD-01 Section 5.3

#### DT-017: Quality Gate Validation
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** String (output) → ValidationResult
**Dependencies:** IM-4001 (QualityGateValidator), IM-4010 (validate method)
**L3 Reference:** L3-CDD-04 Section 4.3

#### DT-018: Quality Score Calculation
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** (failures[], warnings[]) → score (0-100)
**Formula:** `100 - (failures * 25) - (warnings * 5)`
**Dependencies:** IM-4011 (calculate_quality_score)
**L3 Reference:** L3-CDD-04 Section 4.3

#### DT-019: Markdown → PDF Conversion
**Location:** `src-tauri/src/export/pdf.rs`
**Type:** String (markdown) → PDF bytes
**Dependencies:** IP-026, External: markdown-pdf
**L3 Reference:** L2-ICD-01 Section 2.4

#### DT-020: SessionStatus Enum → String
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Enum → SQL TEXT
**Mapping:** Running/Completed/Failed/Paused
**Dependencies:** IP-020 (update_session_status)
**L3 Reference:** L3-CDD-05 Section 3.1

---

## 4. Implementation Inventory (IM-XXXX)

### 4.1 Backend Core Types (1000-1999)

#### IM-1001: AppState Struct
**Location:** `src-tauri/src/main.rs`
**Type:** Rust struct
**Dependencies:** IM-2001, IM-5001
**L3 Reference:** L2-ICD-01 Section 4.1
```rust
pub struct AppState {
    pub orchestrator: Arc<Mutex<AgentOrchestrator>>,
    pub state_manager: Arc<StateManager>,
    pub config: Arc<RwLock<AppConfig>>,
}
```

#### IM-1002: ApiKeyConfig Struct
**Location:** `src-tauri/src/types.rs`
**Type:** Rust struct
**Dependencies:** IP-006
**L3 Reference:** L2-ICD-01 Section 4.2
```rust
pub struct ApiKeyConfig {
    pub anthropic: Option<String>,
    pub google: Option<String>,
    pub deepseek: Option<String>,
    pub tavily: Option<String>,
    pub newsapi: Option<String>,
}
```

#### IM-1003: AppConfig Struct
**Location:** `src-tauri/src/types.rs`
**Type:** Rust struct
**Dependencies:** IM-1002, IM-1004
**L3 Reference:** L2-ICD-01 Section 4.2

#### IM-1004: ModelPreferences Struct
**Location:** `src-tauri/src/types.rs`
**Type:** Rust struct
**L3 Reference:** L2-ICD-01 Section 4.2
```rust
pub struct ModelPreferences {
    pub phase_1_model: String, // "deepseek-chat"
    pub phase_2_model: String, // "deepseek-chat"
    pub phase_3_model: String, // "deepseek-chat"
    pub phase_4_model: Option<String>, // None (logic-based)
    pub phase_5_model: String, // "claude-3-5-sonnet"
}
```

#### IM-1100: ManifestParser Module
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** Rust module
**Dependencies:** IP-025
**L3 Reference:** L3-CDD-01 Section 4.1

#### IM-1101: ProcessManifest Struct
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** Rust struct (deserialized from YAML)
**Dependencies:** DT-008
**L3 Reference:** L3-CDD-01 Section 4.1

#### IM-1102: PhaseDefinition Struct
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-01 Section 4.1

#### IM-1103: ToolCall Struct
**Location:** `src-tauri/src/manifest/mod.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-01 Section 4.1

### 4.2 AgentOrchestrator (2000-2999)

#### IM-2001: AgentOrchestrator Struct
**Location:** `src-tauri/src/agent.rs`
**Type:** Rust struct
**Dependencies:** IM-1101, IM-2100, IM-3001, IM-4001, IM-5001
**L3 Reference:** L3-CDD-01 Section 4.1
```rust
pub struct AgentOrchestrator {
    manifest: ProcessManifest,
    tool_registry: ToolRegistry,
    llm_client: LLMClient,
    quality_gates: QualityGateValidator,
    state_manager: Arc<StateManager>,
    context: HashMap<String, Value>,
}
```

##### Field-Level Inventory

#### IM-2001-F1: manifest Field
**Type:** ProcessManifest
**Mutability:** Immutable after construction
**Purpose:** Workflow phase definitions from YAML
**Dependencies:** IM-1101

#### IM-2001-F2: tool_registry Field
**Type:** ToolRegistry
**Mutability:** Mutable (tool execution modifies logs)
**Purpose:** External tool management (Tavily, NewsAPI)
**Dependencies:** IM-2100

#### IM-2001-F3: llm_client Field
**Type:** LLMClient
**Mutability:** Mutable (request logs accumulate)
**Purpose:** Multi-provider LLM integration
**Dependencies:** IM-3010

#### IM-2001-F4: quality_gates Field
**Type:** QualityGateValidator
**Mutability:** Mutable (validation logs accumulate)
**Purpose:** Output quality validation
**Dependencies:** IM-4001

#### IM-2001-F5: state_manager Field
**Type:** Arc<StateManager>
**Mutability:** Shared ownership (SQLite writes inside)
**Purpose:** Persistent session/phase storage
**Dependencies:** IM-5001

#### IM-2001-F6: context Field
**Type:** HashMap<String, Value>
**Mutability:** Mutable (accumulates phase results)
**Purpose:** Workflow context (company name, phase outputs)
**Dependencies:** None

#### IM-2002: AgentOrchestrator::new()
**Location:** `src-tauri/src/agent.rs`
**Type:** Constructor
**L3 Reference:** L3-CDD-01 Section 4.2
```rust
pub fn new(
    manifest_path: &str,
    llm_client: LLMClient,
    state_manager: StateManager,
) -> Result<Self>
```

##### Parameter-Level Inventory

#### IM-2002-P1: manifest_path Parameter
**Type:** &str
**Validation:** Must be non-empty, valid file path, valid YAML
**Error Paths:** IM-2002-E1, IM-2002-E2, IM-2002-E3

#### IM-2002-P2: llm_client Parameter
**Type:** LLMClient
**Validation:** Must have valid API keys configured
**Error Paths:** IM-2002-E4

#### IM-2002-P3: state_manager Parameter
**Type:** StateManager
**Validation:** Must have valid SQLite connection
**Error Paths:** IM-2002-E5

##### Variable-Level Inventory

#### IM-2002-V1: manifest Variable
**Type:** ProcessManifest
**Initialization:** Loaded from YAML file via DT-008
**Scope:** Local variable, moved to struct

#### IM-2002-V2: tool_registry Variable
**Type:** ToolRegistry
**Initialization:** ToolRegistry::new() with default tools
**Scope:** Local variable, moved to struct

#### IM-2002-V3: quality_gates Variable
**Type:** QualityGateValidator
**Initialization:** QualityGateValidator::new() with all gates
**Scope:** Local variable, moved to struct

#### IM-2002-V4: context Variable
**Type:** HashMap<String, Value>
**Initialization:** Empty HashMap::new()
**Scope:** Local variable, moved to struct

##### Branch-Level Inventory

#### IM-2002-B1: File Exists Check
**Condition:** `!Path::new(manifest_path).exists()`
**True Path:** Return IM-2002-E2
**False Path:** Continue to file read

#### IM-2002-B2: YAML Parse Success
**Condition:** `serde_yaml::from_str::<ProcessManifest>(content)`
**Success Path:** Assign to IM-2002-V1
**Error Path:** Return IM-2002-E3

#### IM-2002-B3: Tool Registration Loop
**Condition:** For each default tool in [TavilySearchTool, NewsAPISearchTool, ManualInputTool]
**Iterations:** 3 tools
**Branch:** Register each tool via IM-2102

##### Error-Path Inventory

#### IM-2002-E1: Empty Path Error
**Trigger:** manifest_path.is_empty()
**Error Type:** ValidationError
**Message:** "manifest_path cannot be empty"

#### IM-2002-E2: File Not Found Error
**Trigger:** !Path::new(manifest_path).exists()
**Error Type:** IoError
**Message:** "Manifest file not found: {path}"

#### IM-2002-E3: YAML Parse Error
**Trigger:** serde_yaml::from_str() fails
**Error Type:** DeserializationError
**Message:** "Invalid YAML manifest: {yaml_error}"

#### IM-2002-E4: Missing API Keys Error
**Trigger:** llm_client.api_keys.is_empty()
**Error Type:** ConfigError
**Message:** "No LLM API keys configured"

#### IM-2002-E5: Database Connection Error
**Trigger:** state_manager.test_connection() fails
**Error Type:** DatabaseError
**Message:** "StateManager database not accessible"

#### IM-2010: AgentOrchestrator::run_workflow()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IM-2011, IM-2012, IM-2020
**L3 Reference:** L3-CDD-01 Section 5.1
```rust
pub async fn run_workflow(
    &mut self,
    company: String,
    window: Option<&Window>,
) -> Result<WorkflowResult>
```

##### Parameter-Level Inventory

#### IM-2010-P1: company Parameter
**Type:** String
**Validation:** Must be non-empty, no whitespace-only
**Error Paths:** IM-2010-E1, IM-2010-E2

#### IM-2010-P2: window Parameter
**Type:** Option<&Window>
**Validation:** None required (optional)
**Usage:** If Some(), emit progress events; if None, skip emissions

##### Variable-Level Inventory

#### IM-2010-V1: session_id Variable
**Type:** String
**Initialization:** state_manager.create_session(&company)
**Scope:** Function-wide, used for all phase saves

#### IM-2010-V2: accumulated_output Variable
**Type:** String
**Initialization:** Empty string
**Scope:** Accumulates phase outputs for final markdown

#### IM-2010-V3: total_cost Variable
**Type:** f64
**Initialization:** 0.0
**Scope:** Accumulates LLM + tool costs across phases

#### IM-2010-V4: phase_results Variable
**Type:** Vec<PhaseResult>
**Initialization:** Empty vector
**Scope:** Collects all phase execution results

#### IM-2010-V5: start_time Variable
**Type:** Instant
**Initialization:** Instant::now()
**Scope:** Measures total workflow duration

##### Branch-Level Inventory

#### IM-2010-B1: Company Name Validation
**Condition:** `company.trim().is_empty()`
**True Path:** Return IM-2010-E2
**False Path:** Continue with session creation

#### IM-2010-B2: Session Creation Success
**Condition:** `state_manager.create_session(&company)`
**Success Path:** Store session_id in IM-2010-V1
**Error Path:** Return IM-2010-E3

#### IM-2010-B3: Window Present Check
**Condition:** `if let Some(window) = window`
**True Path:** Emit IP-007 workflow_started event
**False Path:** Skip event emission

#### IM-2010-B4: Phase Execution Loop
**Condition:** For each phase in manifest.phases
**Iterations:** Variable (typically 5 phases)
**Branch:** Execute IM-2011 for each phase

#### IM-2010-B5: Dependency Check Before Phase
**Condition:** `!self.check_dependencies(&phase)?`
**True Path:** Return IM-2010-E4 (missing dependencies)
**False Path:** Continue to phase execution

#### IM-2010-B6: Phase Execution Success
**Condition:** `self.execute_phase(&phase, window).await`
**Success Path:** Store phase output, continue loop
**Error Path:** Mark session failed, return IM-2010-E5

#### IM-2010-B7: Final Quality Gates
**Condition:** `self.quality_gates.validate(&accumulated_output, &session_id)?`
**Success Path:** Mark session completed, return WorkflowResult
**Error Path:** Mark session failed, return IM-2010-E6

##### Error-Path Inventory

#### IM-2010-E1: Empty Company Name Error
**Trigger:** company.is_empty()
**Error Type:** ValidationError
**Message:** "company name cannot be empty"

#### IM-2010-E2: Whitespace-Only Company Name Error
**Trigger:** company.trim().is_empty()
**Error Type:** ValidationError
**Message:** "company name cannot be whitespace-only"

#### IM-2010-E3: Session Creation Failed Error
**Trigger:** state_manager.create_session() returns Err
**Error Type:** DatabaseError
**Message:** "Failed to create session: {db_error}"

#### IM-2010-E4: Missing Phase Dependencies Error
**Trigger:** check_dependencies() returns false
**Error Type:** WorkflowError
**Message:** "Phase {phase_id} missing required context keys: {missing_keys}"

#### IM-2010-E5: Phase Execution Failed Error
**Trigger:** execute_phase() returns Err
**Error Type:** WorkflowError
**Message:** "Phase {phase_id} failed: {phase_error}"

#### IM-2010-E6: Quality Gates Failed Error
**Trigger:** quality_gates.validate() returns failure
**Error Type:** ValidationError
**Message:** "Output failed quality gates: {failures}"

#### IM-2010-E7: State Save Failed Error
**Trigger:** state_manager.update_session_status() returns Err
**Error Type:** DatabaseError
**Message:** "Failed to save final session state: {db_error}"

#### IM-2011: AgentOrchestrator::execute_phase()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IM-2013, IM-2014, IM-2015
**L3 Reference:** L3-CDD-01 Section 5.3
```rust
async fn execute_phase(
    &mut self,
    phase: &Phase,
    window: &Option<&Window>,
) -> Result<String>
```

##### Parameter-Level Inventory

#### IM-2011-P1: phase Parameter
**Type:** &Phase
**Validation:** Must have valid phase_id, prompt_template
**Error Paths:** IM-2011-E1

#### IM-2011-P2: window Parameter
**Type:** &Option<&Window>
**Validation:** None required
**Usage:** Pass through to emit_progress()

##### Variable-Level Inventory

#### IM-2011-V1: phase_start Variable
**Type:** Instant
**Initialization:** Instant::now()
**Scope:** Measure phase execution time

#### IM-2011-V2: tool_results Variable
**Type:** Vec<String>
**Initialization:** Empty vector
**Scope:** Collect results from tool executions

#### IM-2011-V3: prompt Variable
**Type:** String
**Initialization:** Render phase.prompt_template with context
**Scope:** Prompt sent to LLM

#### IM-2011-V4: llm_output Variable
**Type:** String
**Initialization:** Result from generate_llm_response()
**Scope:** Raw LLM response before validation

#### IM-2011-V5: validated_output Variable
**Type:** String
**Initialization:** Result from validate_output()
**Scope:** Final phase output after quality gates

#### IM-2011-V6: phase_duration Variable
**Type:** u64 (milliseconds)
**Initialization:** phase_start.elapsed().as_millis()
**Scope:** Duration for state persistence

#### IM-2011-V7: phase_cost Variable
**Type:** f64
**Initialization:** Sum of tool costs + LLM cost
**Scope:** Cost tracking for analytics

##### Branch-Level Inventory

#### IM-2011-B1: Tools Present Check
**Condition:** `if !phase.tool_calls.is_empty()`
**True Path:** Execute IM-2013 for each tool
**False Path:** Skip tool execution

#### IM-2011-B2: Tool Execution Loop
**Condition:** For each tool in phase.tool_calls
**Iterations:** Variable (0-10 tools per phase)
**Branch:** Execute tool via IM-2013

#### IM-2011-B3: Window Progress Emission
**Condition:** `if let Some(window) = window`
**True Path:** Emit IP-008 phase_started, IP-009 tool_completed, IP-010 phase_completed
**False Path:** Skip emissions

#### IM-2011-B4: Prompt Template Rendering
**Condition:** `render_template(&phase.prompt_template, &self.context)`
**Success Path:** Assign to IM-2011-V3
**Error Path:** Return IM-2011-E2

#### IM-2011-B5: LLM Generation Success
**Condition:** `self.generate_llm_response(&phase.model, &prompt).await`
**Success Path:** Assign to IM-2011-V4
**Error Path:** Return IM-2011-E3

#### IM-2011-B6: Validation Success
**Condition:** `self.validate_output(&llm_output, phase.validation_gates).await`
**Success Path:** Assign to IM-2011-V5
**Error Path:** Return IM-2011-E4

#### IM-2011-B7: Context Update
**Condition:** Update self.context with phase output
**Success Path:** Insert phase_id → validated_output
**Error Path:** Not applicable (infallible)

#### IM-2011-B8: State Persistence
**Condition:** `self.state_manager.save_phase_completion(...)`
**Success Path:** Phase persisted to SQLite
**Error Path:** Return IM-2011-E5

##### Error-Path Inventory

#### IM-2011-E1: Invalid Phase Definition Error
**Trigger:** phase.phase_id.is_empty() || phase.prompt_template.is_empty()
**Error Type:** ValidationError
**Message:** "Invalid phase definition: missing required fields"

#### IM-2011-E2: Template Rendering Failed Error
**Trigger:** render_template() returns Err
**Error Type:** TemplateError
**Message:** "Failed to render prompt template: {template_error}"

#### IM-2011-E3: LLM Generation Failed Error
**Trigger:** generate_llm_response() returns Err
**Error Type:** LLMError
**Message:** "LLM generation failed for phase {phase_id}: {llm_error}"

#### IM-2011-E4: Validation Failed Error
**Trigger:** validate_output() returns Err
**Error Type:** ValidationError
**Message:** "Phase output failed validation: {validation_errors}"

#### IM-2011-E5: State Persistence Failed Error
**Trigger:** save_phase_completion() returns Err
**Error Type:** DatabaseError
**Message:** "Failed to persist phase state: {db_error}"

#### IM-2012: AgentOrchestrator::check_dependencies()
**Location:** `src-tauri/src/agent.rs`
**Type:** Method
**L3 Reference:** L3-CDD-01 Section 5.2

##### Parameter-Level Inventory

#### IM-2012-P1: phase Parameter
**Type:** &Phase
**Validation:** Must have valid phase_id and dependencies list
**Error Paths:** None (references validated Phase struct)

##### Variable-Level Inventory

#### IM-2012-V1: missing_keys Variable
**Type:** Vec<String>
**Initialization:** Vec::new()
**Scope:** Accumulates missing context keys
**Purpose:** Collect all missing dependencies for error reporting

#### IM-2012-V2: has_dependency Variable
**Type:** bool
**Initialization:** Result of context.contains_key(dep)
**Scope:** Loop iteration variable
**Purpose:** Check if each dependency exists in context

##### Branch-Level Inventory

#### IM-2012-B1: Phase Has Dependencies Check
**Condition:** `phase.dependencies.is_some()`
**True Path:** Iterate through dependencies (IM-2012-B2)
**False Path:** Return Ok(true) - no dependencies to check

#### IM-2012-B2: Dependencies Iteration Loop
**Condition:** For each dep in phase.dependencies.unwrap()
**Iterations:** Variable (0-10 typical)
**Branch:** Check if context contains key (IM-2012-B3)

#### IM-2012-B3: Dependency Exists Check
**Condition:** `self.context.contains_key(dep)`
**True Path:** Continue to next dependency
**False Path:** Add to missing_keys (IM-2012-V1)

#### IM-2012-B4: Missing Dependencies Check
**Condition:** `!missing_keys.is_empty()`
**True Path:** Return Ok(false) with missing keys list
**False Path:** Return Ok(true) - all dependencies satisfied

##### Error-Path Inventory

#### IM-2012-E1: No Error Paths
**Note:** This method returns Result<bool> but does not error - uses false return for missing dependencies

#### IM-2013: AgentOrchestrator::execute_tools()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IM-2101 (ToolRegistry::execute)
**L3 Reference:** L3-CDD-01 Section 5.4

##### Parameter-Level Inventory

#### IM-2013-P1: tool_calls Parameter
**Type:** Vec<ToolCall>
**Validation:** Must be non-empty, each ToolCall must have valid tool_name and arguments
**Error Paths:** IM-2013-E1, IM-2013-E2

##### Variable-Level Inventory

#### IM-2013-V1: results Variable
**Type:** Vec<String>
**Initialization:** Vec::with_capacity(tool_calls.len())
**Scope:** Accumulates tool execution results
**Purpose:** Collect all tool outputs for phase processing

#### IM-2013-V2: tool_result Variable
**Type:** String
**Initialization:** Result from self.tool_registry.execute()
**Scope:** Loop iteration variable
**Purpose:** Individual tool execution result

#### IM-2013-V3: tool_name Variable
**Type:** &str
**Initialization:** tool_call.tool_name.as_str()
**Scope:** Loop iteration variable
**Purpose:** Reference to requested tool name

#### IM-2013-V4: tool_args Variable
**Type:** &Value
**Initialization:** &tool_call.arguments
**Scope:** Loop iteration variable
**Purpose:** Arguments to pass to tool execution

##### Branch-Level Inventory

#### IM-2013-B1: Empty Tool Calls Check
**Condition:** `tool_calls.is_empty()`
**True Path:** Return IM-2013-E1
**False Path:** Continue to tool execution loop

#### IM-2013-B2: Tool Execution Loop
**Condition:** For each tool_call in tool_calls.iter()
**Iterations:** Variable (1-10 typical)
**Branch:** Execute tool via IM-2101

#### IM-2013-B3: Tool Execution Success Check
**Condition:** `self.tool_registry.execute(tool_name, tool_args)`
**Success Path:** Push result to results (IM-2013-V1)
**Error Path:** Return IM-2013-E2 or IM-2013-E3

#### IM-2013-B4: All Tools Completed Check
**Condition:** `results.len() == tool_calls.len()`
**True Path:** Return Ok(results)
**False Path:** Return IM-2013-E4 (incomplete execution)

##### Error-Path Inventory

#### IM-2013-E1: Empty Tool Calls Error
**Trigger:** tool_calls.is_empty()
**Error Type:** ValidationError
**Message:** "execute_tools called with empty tool_calls vector"

#### IM-2013-E2: Tool Not Found Error
**Trigger:** tool_registry.execute() returns Err(ToolNotFound)
**Error Type:** ToolExecutionError
**Message:** "Tool '{tool_name}' not found in registry"

#### IM-2013-E3: Tool Execution Failed Error
**Trigger:** tool_registry.execute() returns Err(ExecutionError)
**Error Type:** ToolExecutionError
**Message:** "Tool '{tool_name}' execution failed: {error_details}"

#### IM-2013-E4: Incomplete Execution Error
**Trigger:** results.len() != tool_calls.len() after loop
**Error Type:** InternalError
**Message:** "Tool execution incomplete: expected {expected}, got {actual}"

#### IM-2014: AgentOrchestrator::generate_llm_response()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IM-3010 (LLMClient::generate)
**L3 Reference:** L3-CDD-01 Section 5.5

##### Parameter-Level Inventory

#### IM-2014-P1: phase Parameter
**Type:** &Phase
**Validation:** Must have valid prompt template
**Error Paths:** IM-2014-E1

#### IM-2014-P2: tool_results Parameter
**Type:** Option<Vec<String>>
**Validation:** None required (optional)
**Usage:** If Some, include in context; if None, skip tool results

##### Variable-Level Inventory

#### IM-2014-V1: prompt Variable
**Type:** String
**Initialization:** phase.prompt.clone()
**Scope:** Template to be populated with context
**Purpose:** Base prompt before variable substitution

#### IM-2014-V2: filled_prompt Variable
**Type:** String
**Initialization:** Result of template substitution via DT-009
**Scope:** Prompt with all variables replaced
**Purpose:** Final prompt sent to LLM

#### IM-2014-V3: llm_request Variable
**Type:** LLMRequest
**Initialization:** LLMRequest builder with model, prompt, temperature
**Scope:** Request struct passed to IM-3012
**Purpose:** Encapsulate LLM request parameters

#### IM-2014-V4: llm_response Variable
**Type:** LLMResponse
**Initialization:** Result from self.llm_client.generate()
**Scope:** Response from LLM API call
**Purpose:** Contains generated text and metadata

#### IM-2014-V5: context_data Variable
**Type:** HashMap<String, String>
**Initialization:** self.context + tool_results (if provided)
**Scope:** All available data for template substitution
**Purpose:** Combined context for prompt filling

##### Branch-Level Inventory

#### IM-2014-B1: Empty Prompt Check
**Condition:** `phase.prompt.is_empty()`
**True Path:** Return IM-2014-E1
**False Path:** Continue to prompt filling

#### IM-2014-B2: Tool Results Present Check
**Condition:** `tool_results.is_some()`
**True Path:** Add tool results to context_data (IM-2014-V5)
**False Path:** Use only self.context

#### IM-2014-B3: Template Substitution Success
**Condition:** DT-009 template substitution
**Success Path:** Assign to filled_prompt (IM-2014-V2)
**Error Path:** Return IM-2014-E2

#### IM-2014-B4: LLM API Call Success
**Condition:** `self.llm_client.generate(llm_request).await`
**Success Path:** Assign to llm_response (IM-2014-V4)
**Error Path:** Return IM-2014-E3 or IM-2014-E4

#### IM-2014-B5: Response Validation
**Condition:** `!llm_response.content.is_empty()`
**True Path:** Return Ok(llm_response)
**False Path:** Return IM-2014-E5

##### Error-Path Inventory

#### IM-2014-E1: Empty Prompt Error
**Trigger:** phase.prompt.is_empty()
**Error Type:** ValidationError
**Message:** "Phase '{phase_id}' has empty prompt template"

#### IM-2014-E2: Template Substitution Error
**Trigger:** DT-009 returns Err (missing variable)
**Error Type:** TemplateError
**Message:** "Failed to fill prompt template: missing variable '{var_name}'"

#### IM-2014-E3: LLM API Error
**Trigger:** llm_client.generate() returns Err(ApiError)
**Error Type:** LLMError
**Message:** "LLM API request failed: {api_error}"

#### IM-2014-E4: LLM Timeout Error
**Trigger:** llm_client.generate() returns Err(Timeout)
**Error Type:** LLMError
**Message:** "LLM request timed out after {timeout_seconds}s"

#### IM-2014-E5: Empty Response Error
**Trigger:** llm_response.content.is_empty()
**Error Type:** LLMError
**Message:** "LLM returned empty response for phase '{phase_id}'"

#### IM-2015: AgentOrchestrator::validate_output()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IM-4010 (QualityGateValidator::validate)
**L3 Reference:** L3-CDD-01 Section 5.6

##### Parameter-Level Inventory

#### IM-2015-P1: phase Parameter
**Type:** &Phase
**Validation:** Must have valid quality_gates configuration
**Error Paths:** IM-2015-E1

#### IM-2015-P2: output Parameter
**Type:** &str
**Validation:** Must be non-empty
**Error Paths:** IM-2015-E2

##### Variable-Level Inventory

#### IM-2015-V1: validation_result Variable
**Type:** ValidationResult
**Initialization:** Result from self.quality_gates.validate()
**Scope:** Contains pass/fail and detailed validation metrics
**Purpose:** Quality gate validation outcome

#### IM-2015-V2: gates_to_check Variable
**Type:** Vec<GateType>
**Initialization:** phase.quality_gates.unwrap_or_default()
**Scope:** List of quality gates to apply
**Purpose:** Defines which validations to run

#### IM-2015-V3: gate_results Variable
**Type:** HashMap<GateType, bool>
**Initialization:** HashMap::new()
**Scope:** Per-gate pass/fail results
**Purpose:** Track which gates passed/failed

##### Branch-Level Inventory

#### IM-2015-B1: Empty Output Check
**Condition:** `output.is_empty()`
**True Path:** Return IM-2015-E2
**False Path:** Continue to validation

#### IM-2015-B2: Quality Gates Configured Check
**Condition:** `phase.quality_gates.is_some()`
**True Path:** Use configured gates (IM-2015-V2)
**False Path:** Return IM-2015-E1

#### IM-2015-B3: Gate Validation Loop
**Condition:** For each gate in gates_to_check
**Iterations:** Variable (1-5 typical)
**Branch:** Run validation via IM-4010

#### IM-2015-B4: Validation Success Check
**Condition:** `validation_result.passed`
**True Path:** Return Ok(validation_result)
**False Path:** Return IM-2015-E3

##### Error-Path Inventory

#### IM-2015-E1: No Quality Gates Configured Error
**Trigger:** phase.quality_gates.is_none()
**Error Type:** ConfigurationError
**Message:** "Phase '{phase_id}' has no quality gates configured"

#### IM-2015-E2: Empty Output Error
**Trigger:** output.is_empty()
**Error Type:** ValidationError
**Message:** "Cannot validate empty output for phase '{phase_id}'"

#### IM-2015-E3: Validation Failed Error
**Trigger:** validation_result.passed == false
**Error Type:** QualityGateError
**Message:** "Quality gates failed for phase '{phase_id}': {failed_gates}"

#### IM-2020: AgentOrchestrator::emit_progress()
**Location:** `src-tauri/src/agent.rs`
**Type:** Async method
**Dependencies:** IP-007 through IP-013
**L3 Reference:** L3-CDD-01 Section 5.6

##### Parameter-Level Inventory

#### IM-2020-P1: window Parameter
**Type:** Option<&Window>
**Validation:** None required (optional)
**Usage:** If Some, emit events; if None, skip emission

#### IM-2020-P2: event_type Parameter
**Type:** ProgressEventType
**Validation:** Must be valid enum variant
**Error Paths:** None (type-safe)

#### IM-2020-P3: data Parameter
**Type:** Value
**Validation:** Must be valid JSON serializable
**Error Paths:** IM-2020-E1

##### Variable-Level Inventory

#### IM-2020-V1: event_payload Variable
**Type:** ProgressEvent
**Initialization:** ProgressEvent { event_type, timestamp, data }
**Scope:** Struct to be emitted to frontend
**Purpose:** Encapsulate progress event data

#### IM-2020-V2: timestamp Variable
**Type:** SystemTime
**Initialization:** SystemTime::now()
**Scope:** Current timestamp for event
**Purpose:** Track when event occurred

#### IM-2020-V3: serialized_payload Variable
**Type:** String
**Initialization:** serde_json::to_string(&event_payload)
**Scope:** JSON string to emit
**Purpose:** Serialized event for frontend consumption

##### Branch-Level Inventory

#### IM-2020-B1: Window Provided Check
**Condition:** `window.is_some()`
**True Path:** Continue to event emission
**False Path:** Return Ok(()) - no window, skip emission

#### IM-2020-B2: Serialization Success Check
**Condition:** `serde_json::to_string(&event_payload)`
**Success Path:** Assign to serialized_payload (IM-2020-V3)
**Error Path:** Return IM-2020-E1

#### IM-2020-B3: Event Emission Success Check
**Condition:** `window.unwrap().emit(event_type.as_str(), serialized_payload)`
**Success Path:** Return Ok(())
**Error Path:** Return IM-2020-E2

##### Error-Path Inventory

#### IM-2020-E1: Serialization Error
**Trigger:** serde_json::to_string() fails
**Error Type:** SerializationError
**Message:** "Failed to serialize progress event: {serde_error}"

#### IM-2020-E2: Emission Error
**Trigger:** window.emit() returns Err
**Error Type:** EmissionError
**Message:** "Failed to emit progress event '{event_type}': {tauri_error}"

#### IM-2100: ToolRegistry Struct
**Location:** `src-tauri/src/tools/mod.rs`
**Type:** Rust struct
**Dependencies:** IM-2110, IM-2120, IM-2130
**L3 Reference:** L3-CDD-02 Section 4.1

##### Field-Level Inventory

#### IM-2100-F1: tools Field
**Type:** HashMap<String, Box<dyn Tool>>
**Mutability:** Mutable (tools can be registered/removed)
**Purpose:** Map of tool names to tool implementations
**Dependencies:** IM-2200 (Tool trait)

#### IM-2100-F2: execution_logs Field
**Type:** Vec<ToolExecutionLog>
**Mutability:** Mutable (logs accumulate on each execution)
**Purpose:** Historical record of tool invocations
**Dependencies:** None

#### IM-2101: ToolRegistry::execute()
**Location:** `src-tauri/src/tools/mod.rs`
**Type:** Async method
**Dependencies:** IM-2200 (Tool trait)
**L3 Reference:** L3-CDD-02 Section 4.3

##### Parameter-Level Inventory

#### IM-2101-P1: tool_name Parameter
**Type:** &str
**Validation:** Must be non-empty, must exist in registry
**Error Paths:** IM-2101-E1, IM-2101-E2

#### IM-2101-P2: args Parameter
**Type:** &Value
**Validation:** Must match tool's expected schema
**Error Paths:** IM-2101-E3

##### Variable-Level Inventory

#### IM-2101-V1: tool Variable
**Type:** &Box<dyn Tool>
**Initialization:** self.tools.get(tool_name)
**Scope:** Reference to tool implementation
**Purpose:** Execute tool method

#### IM-2101-V2: execution_start Variable
**Type:** Instant
**Initialization:** Instant::now()
**Scope:** Timestamp before execution
**Purpose:** Calculate execution duration

#### IM-2101-V3: result Variable
**Type:** String
**Initialization:** tool.execute(args).await
**Scope:** Tool execution output
**Purpose:** Return value and log entry

#### IM-2101-V4: execution_duration Variable
**Type:** Duration
**Initialization:** execution_start.elapsed()
**Scope:** Time taken for execution
**Purpose:** Performance tracking

#### IM-2101-V5: log_entry Variable
**Type:** ToolExecutionLog
**Initialization:** ToolExecutionLog { tool_name, args, result, duration }
**Scope:** Log record for this execution
**Purpose:** Append to execution_logs

##### Branch-Level Inventory

#### IM-2101-B1: Empty Tool Name Check
**Condition:** `tool_name.is_empty()`
**True Path:** Return IM-2101-E1
**False Path:** Continue to tool lookup

#### IM-2101-B2: Tool Exists Check
**Condition:** `self.tools.get(tool_name)`
**Some Path:** Assign to tool variable (IM-2101-V1)
**None Path:** Return IM-2101-E2

#### IM-2101-B3: Schema Validation Check
**Condition:** `tool.schema().validate(args)`
**Valid Path:** Continue to execution
**Invalid Path:** Return IM-2101-E3

#### IM-2101-B4: Tool Execution Success
**Condition:** `tool.execute(args).await`
**Success Path:** Assign to result (IM-2101-V3), create log entry
**Error Path:** Return IM-2101-E4

##### Error-Path Inventory

#### IM-2101-E1: Empty Tool Name Error
**Trigger:** tool_name.is_empty()
**Error Type:** ValidationError
**Message:** "Tool name cannot be empty"

#### IM-2101-E2: Tool Not Found Error
**Trigger:** self.tools.get(tool_name) returns None
**Error Type:** ToolNotFoundError
**Message:** "Tool '{tool_name}' not registered"

#### IM-2101-E3: Schema Validation Error
**Trigger:** tool.schema().validate(args) returns Err
**Error Type:** ValidationError
**Message:** "Arguments for tool '{tool_name}' do not match schema: {validation_errors}"

#### IM-2101-E4: Tool Execution Error
**Trigger:** tool.execute(args) returns Err
**Error Type:** ToolExecutionError
**Message:** "Tool '{tool_name}' execution failed: {tool_error}"

#### IM-2102: ToolRegistry::register()
**Location:** `src-tauri/src/tools/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-02 Section 4.2

##### Parameter-Level Inventory

#### IM-2102-P1: tool Parameter
**Type:** Box<dyn Tool>
**Validation:** Must implement Tool trait with valid name
**Error Paths:** IM-2102-E1, IM-2102-E2

##### Variable-Level Inventory

#### IM-2102-V1: tool_name Variable
**Type:** String
**Initialization:** tool.name().to_string()
**Scope:** Key for tools HashMap
**Purpose:** Unique identifier for tool

#### IM-2102-V2: existing_tool Variable
**Type:** Option<Box<dyn Tool>>
**Initialization:** self.tools.get(&tool_name)
**Scope:** Check if tool already registered
**Purpose:** Prevent duplicate registration

##### Branch-Level Inventory

#### IM-2102-B1: Empty Tool Name Check
**Condition:** `tool.name().is_empty()`
**True Path:** Return IM-2102-E1
**False Path:** Continue to duplicate check

#### IM-2102-B2: Duplicate Tool Check
**Condition:** `self.tools.contains_key(&tool_name)`
**True Path:** Return IM-2102-E2
**False Path:** Continue to registration

#### IM-2102-B3: Registration Success
**Condition:** `self.tools.insert(tool_name.clone(), tool)`
**Always Succeeds:** HashMap insertion always succeeds
**Side Effect:** Tool now available for execution

##### Error-Path Inventory

#### IM-2102-E1: Empty Tool Name Error
**Trigger:** tool.name().is_empty()
**Error Type:** ValidationError
**Message:** "Cannot register tool with empty name"

#### IM-2102-E2: Duplicate Tool Error
**Trigger:** self.tools.contains_key(&tool_name)
**Error Type:** RegistrationError
**Message:** "Tool '{tool_name}' already registered"

#### IM-2110: TavilySearchTool Struct
**Location:** `src-tauri/src/tools/tavily_search.rs`
**Type:** Rust struct implementing Tool trait
**Dependencies:** IP-017
**L3 Reference:** L3-CDD-02 Section 6.2

##### Field-Level Inventory

#### IM-2110-F1: api_key Field
**Type:** String
**Mutability:** Immutable after construction
**Purpose:** Tavily API authentication
**Dependencies:** IP-017

#### IM-2110-F2: max_results Field
**Type:** usize
**Mutability:** Immutable after construction
**Purpose:** Limit number of search results
**Default:** 5

#### IM-2120: NewsAPISearchTool Struct
**Location:** `src-tauri/src/tools/newsapi_search.rs`
**Type:** Rust struct implementing Tool trait
**Dependencies:** IP-018
**L3 Reference:** L3-CDD-02 Section 6.3

##### Field-Level Inventory

#### IM-2120-F1: api_key Field
**Type:** String
**Mutability:** Immutable after construction
**Purpose:** NewsAPI authentication
**Dependencies:** IP-018

#### IM-2120-F2: language Field
**Type:** String
**Mutability:** Immutable after construction
**Purpose:** Filter news by language
**Default:** "en"

#### IM-2130: ManualInputTool Struct
**Location:** `src-tauri/src/tools/manual_input.rs`
**Type:** Rust struct implementing Tool trait
**L3 Reference:** L3-CDD-02 Section 6.4

##### Field-Level Inventory

#### IM-2130-F1: prompt_message Field
**Type:** String
**Mutability:** Immutable after construction
**Purpose:** User prompt displayed in dialog
**Default:** "Please provide additional information:"

#### IM-2200: Tool Trait
**Location:** `src-tauri/src/tools/mod.rs`
**Type:** Rust async trait
**L3 Reference:** L3-CDD-02 Section 5.1
```rust
#[async_trait]
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn schema(&self) -> ToolSchema;
    async fn execute(&self, args: Value) -> Result<String>;
    fn estimate_cost(&self, args: &Value) -> Option<f64>;
}
```

### 4.3 LLMClient (3000-3999)

#### IM-3001: LLMRequest Struct
**Location:** `src-tauri/src/llm/types.rs`
**Type:** Rust struct
**Dependencies:** DT-004
**L3 Reference:** L3-CDD-03 Section 3.1

##### Field-Level Inventory

#### IM-3001-F1: model Field
**Type:** String
**Mutability:** Immutable
**Purpose:** LLM model identifier (e.g., "claude-3-5-sonnet-20241022")
**Dependencies:** None

#### IM-3001-F2: prompt Field
**Type:** String
**Mutability:** Immutable
**Purpose:** User prompt to send to LLM
**Dependencies:** DT-009 (filled from template)

#### IM-3001-F3: temperature Field
**Type:** f32
**Mutability:** Immutable
**Purpose:** Sampling temperature (0.0-1.0)
**Default:** 0.7

#### IM-3001-F4: max_tokens Field
**Type:** Option<usize>
**Mutability:** Immutable
**Purpose:** Maximum completion length
**Default:** None (provider default)

#### IM-3002: LLMResponse Struct
**Location:** `src-tauri/src/llm/types.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-03 Section 3.1

##### Field-Level Inventory

#### IM-3002-F1: content Field
**Type:** String
**Mutability:** Immutable
**Purpose:** Generated text from LLM
**Dependencies:** None

#### IM-3002-F2: model Field
**Type:** String
**Mutability:** Immutable
**Purpose:** Actual model used for generation
**Dependencies:** None

#### IM-3002-F3: token_usage Field
**Type:** TokenUsage
**Mutability:** Immutable
**Purpose:** Token consumption metrics
**Dependencies:** IM-3003

#### IM-3002-F4: cost Field
**Type:** f64
**Mutability:** Immutable
**Purpose:** Estimated API cost in USD
**Dependencies:** IM-3200 (calculate_cost)

#### IM-3003: TokenUsage Struct
**Location:** `src-tauri/src/llm/types.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-03 Section 3.1

##### Field-Level Inventory

#### IM-3003-F1: input_tokens Field
**Type:** usize
**Mutability:** Immutable
**Purpose:** Prompt token count
**Dependencies:** None

#### IM-3003-F2: output_tokens Field
**Type:** usize
**Mutability:** Immutable
**Purpose:** Completion token count
**Dependencies:** None

#### IM-3003-F3: total_tokens Field
**Type:** usize
**Mutability:** Immutable
**Purpose:** Sum of input + output tokens
**Dependencies:** IM-3003-F1, IM-3003-F2

#### IM-3004: LLMError Enum
**Location:** `src-tauri/src/llm/types.rs`
**Type:** Rust error enum
**L3 Reference:** L3-CDD-03 Section 3.1

##### Variant-Level Inventory

#### IM-3004-V1: ApiError Variant
**Type:** Enum variant with String payload
**Purpose:** HTTP/API errors from LLM provider
**Example:** "401 Unauthorized"

#### IM-3004-V2: TimeoutError Variant
**Type:** Enum variant with Duration payload
**Purpose:** Request exceeded timeout limit
**Example:** Timeout after 30s

#### IM-3004-V3: InvalidModel Variant
**Type:** Enum variant with String payload
**Purpose:** Unsupported or unknown model name
**Example:** "Model 'gpt-5' not found"

#### IM-3004-V4: RateLimitError Variant
**Type:** Enum variant with Option<Duration> payload
**Purpose:** API rate limit exceeded, optional retry-after
**Example:** Rate limit, retry after 60s

#### IM-3010: LLMClient Struct
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Rust struct
**Dependencies:** IM-3100, IM-3110, IM-3120
**L3 Reference:** L3-CDD-03 Section 4.1

##### Field-Level Inventory

#### IM-3010-F1: providers Field
**Type:** HashMap<String, Box<dyn LLMProvider>>
**Mutability:** Mutable (providers can be registered)
**Purpose:** Map of provider names to implementations
**Dependencies:** IM-3100, IM-3110, IM-3120

#### IM-3010-F2: request_logs Field
**Type:** Vec<LLMRequest>
**Mutability:** Mutable (logs accumulate on each request)
**Purpose:** Historical record of LLM requests
**Dependencies:** IM-3001

#### IM-3010-F3: response_cache Field
**Type:** Option<HashMap<String, LLMResponse>>
**Mutability:** Mutable (cache updated on responses)
**Purpose:** Optional response caching by prompt hash
**Dependencies:** IM-3002

#### IM-3011: LLMClient::new()
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Constructor
**L3 Reference:** L3-CDD-03 Section 4.2

##### Parameter-Level Inventory

#### IM-3011-P1: api_keys Parameter
**Type:** HashMap<String, String>
**Validation:** Must contain at least one provider key
**Error Paths:** IM-3011-E1

##### Variable-Level Inventory

#### IM-3011-V1: providers Variable
**Type:** HashMap<String, Box<dyn LLMProvider>>
**Initialization:** HashMap::new()
**Scope:** Populated with default providers
**Purpose:** Initialize provider registry

#### IM-3011-V2: anthropic_provider Variable
**Type:** AnthropicProvider
**Initialization:** AnthropicProvider::new(api_keys.get("anthropic"))
**Scope:** If key exists, register provider
**Purpose:** Enable Claude models

#### IM-3011-V3: gemini_provider Variable
**Type:** GeminiProvider
**Initialization:** GeminiProvider::new(api_keys.get("gemini"))
**Scope:** If key exists, register provider
**Purpose:** Enable Gemini models

#### IM-3011-V4: deepseek_provider Variable
**Type:** DeepSeekProvider
**Initialization:** DeepSeekProvider::new(api_keys.get("deepseek"))
**Scope:** If key exists, register provider
**Purpose:** Enable DeepSeek models

##### Branch-Level Inventory

#### IM-3011-B1: API Keys Empty Check
**Condition:** `api_keys.is_empty()`
**True Path:** Return IM-3011-E1
**False Path:** Continue to provider registration

#### IM-3011-B2: Anthropic Key Check
**Condition:** `api_keys.contains_key("anthropic")`
**True Path:** Create and register AnthropicProvider
**False Path:** Skip Anthropic registration

#### IM-3011-B3: Gemini Key Check
**Condition:** `api_keys.contains_key("gemini")`
**True Path:** Create and register GeminiProvider
**False Path:** Skip Gemini registration

#### IM-3011-B4: DeepSeek Key Check
**Condition:** `api_keys.contains_key("deepseek")`
**True Path:** Create and register DeepSeekProvider
**False Path:** Skip DeepSeek registration

##### Error-Path Inventory

#### IM-3011-E1: No API Keys Error
**Trigger:** api_keys.is_empty()
**Error Type:** ConfigurationError
**Message:** "No LLM API keys provided"

#### IM-3012: LLMClient::generate()
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Async method
**Dependencies:** IM-3013, IM-3300
**L3 Reference:** L3-CDD-03 Section 4.3

##### Parameter-Level Inventory

#### IM-3012-P1: request Parameter
**Type:** LLMRequest
**Validation:** Must have non-empty model and prompt
**Error Paths:** IM-3012-E1, IM-3012-E2

##### Variable-Level Inventory

#### IM-3012-V1: provider_name Variable
**Type:** String
**Initialization:** self.detect_provider(&request.model)
**Scope:** Determined from model name
**Purpose:** Route request to correct provider

#### IM-3012-V2: provider Variable
**Type:** &Box<dyn LLMProvider>
**Initialization:** self.providers.get(&provider_name)
**Scope:** Reference to provider implementation
**Purpose:** Execute generate call

#### IM-3012-V3: response Variable
**Type:** LLMResponse
**Initialization:** provider.generate(request.clone()).await
**Scope:** Result from provider API
**Purpose:** Return value and cache entry

##### Branch-Level Inventory

#### IM-3012-B1: Empty Model Check
**Condition:** `request.model.is_empty()`
**True Path:** Return IM-3012-E1
**False Path:** Continue to provider detection

#### IM-3012-B2: Empty Prompt Check
**Condition:** `request.prompt.is_empty()`
**True Path:** Return IM-3012-E2
**False Path:** Continue to provider lookup

#### IM-3012-B3: Provider Exists Check
**Condition:** `self.providers.get(&provider_name)`
**Some Path:** Assign to provider variable
**None Path:** Return IM-3012-E3

#### IM-3012-B4: Generation Success
**Condition:** `provider.generate(request.clone()).await`
**Success Path:** Log request, return response
**Error Path:** Return IM-3012-E4

##### Error-Path Inventory

#### IM-3012-E1: Empty Model Error
**Trigger:** request.model.is_empty()
**Error Type:** ValidationError
**Message:** "LLM model cannot be empty"

#### IM-3012-E2: Empty Prompt Error
**Trigger:** request.prompt.is_empty()
**Error Type:** ValidationError
**Message:** "LLM prompt cannot be empty"

#### IM-3012-E3: Provider Not Found Error
**Trigger:** self.providers.get(&provider_name) returns None
**Error Type:** LLMError
**Message:** "No provider available for model '{model}'"

#### IM-3012-E4: Generation Failed Error
**Trigger:** provider.generate() returns Err
**Error Type:** LLMError
**Message:** "LLM generation failed: {provider_error}"

#### IM-3013: LLMClient::detect_provider()
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-03 Section 4.3

##### Parameter-Level Inventory

#### IM-3013-P1: model Parameter
**Type:** &str
**Validation:** Must be non-empty
**Error Paths:** None (returns default on unknown)

##### Variable-Level Inventory

#### IM-3013-V1: provider_name Variable
**Type:** String
**Initialization:** Detected from model prefix
**Scope:** Return value
**Purpose:** Provider identifier for routing

##### Branch-Level Inventory

#### IM-3013-B1: Model Prefix Check (Anthropic)
**Condition:** `model.starts_with("claude-")`
**True Path:** Return "anthropic"
**False Path:** Check next provider

#### IM-3013-B2: Model Prefix Check (Gemini)
**Condition:** `model.starts_with("gemini-")`
**True Path:** Return "gemini"
**False Path:** Check next provider

#### IM-3013-B3: Model Prefix Check (DeepSeek)
**Condition:** `model.starts_with("deepseek-")`
**True Path:** Return "deepseek"
**False Path:** Return "anthropic" (default)

#### IM-3014: LLMClient::total_cost()
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-03 Section 4.3

##### Variable-Level Inventory

#### IM-3014-V1: total Variable
**Type:** f64
**Initialization:** 0.0
**Scope:** Accumulator for summing costs
**Purpose:** Return value

##### Branch-Level Inventory

#### IM-3014-B1: Request Logs Iteration
**Condition:** For each request in self.request_logs
**Iterations:** Variable (0-1000+ typical)
**Branch:** Sum cost for each request via IM-3200

#### IM-3100: AnthropicProvider Struct
**Location:** `src-tauri/src/llm/providers/anthropic.rs`
**Type:** Rust struct implementing LLMProvider trait
**Dependencies:** IP-014
**L3 Reference:** L3-CDD-03 Section 6.1

#### IM-3110: GeminiProvider Struct
**Location:** `src-tauri/src/llm/providers/gemini.rs`
**Type:** Rust struct implementing LLMProvider trait
**Dependencies:** IP-015
**L3 Reference:** L3-CDD-03 Section 6.2

#### IM-3120: DeepSeekProvider Struct
**Location:** `src-tauri/src/llm/providers/deepseek.rs`
**Type:** Rust struct implementing LLMProvider trait
**Dependencies:** IP-016
**L3 Reference:** L3-CDD-03 Section 6.3

#### IM-3200: calculate_cost() Function
**Location:** `src-tauri/src/llm/cost.rs`
**Type:** Pure function
**Dependencies:** DT-015
**L3 Reference:** L3-CDD-03 Section 8.1

#### IM-3300: with_exponential_backoff() Function
**Location:** `src-tauri/src/llm/retry.rs`
**Type:** Async function (generic)
**L3 Reference:** L3-CDD-03 Section 7.1

#### IM-3400: LLMProvider Trait
**Location:** `src-tauri/src/llm/providers/mod.rs`
**Type:** Rust async trait
**L3 Reference:** L3-CDD-03 Section 5.1

### 4.4 QualityGates (4000-4999)

#### IM-4001: QualityGateValidator Struct
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Rust struct
**Dependencies:** IM-4100 through IM-4150
**L3 Reference:** L3-CDD-04 Section 4.1

##### Field-Level Inventory

#### IM-4001-F1: gates Field
**Type:** Vec<Box<dyn QualityGate>>
**Mutability:** Immutable after construction
**Purpose:** Collection of registered quality gates
**Dependencies:** IM-4100 through IM-4150

#### IM-4001-F2: validation_logs Field
**Type:** Vec<ValidationResult>
**Mutability:** Mutable (logs accumulate on validation)
**Purpose:** Historical record of validations
**Dependencies:** IM-4300

#### IM-4002: QualityGateValidator::new()
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Constructor
**L3 Reference:** L3-CDD-04 Section 4.2

##### Variable-Level Inventory

#### IM-4002-V1: gates Variable
**Type:** Vec<Box<dyn QualityGate>>
**Initialization:** Vec containing default 6 gates
**Scope:** Registered quality gates
**Purpose:** Initialize validator with all gates

#### IM-4010: QualityGateValidator::validate()
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Async method
**Dependencies:** IM-4011, IM-4012, IM-4200
**L3 Reference:** L3-CDD-04 Section 4.3

##### Parameter-Level Inventory

#### IM-4010-P1: text Parameter
**Type:** &str
**Validation:** Must be non-empty
**Error Paths:** IM-4010-E1

#### IM-4010-P2: gate_types Parameter
**Type:** Vec<GateType>
**Validation:** Must be non-empty, valid gate types
**Error Paths:** IM-4010-E2

##### Variable-Level Inventory

#### IM-4010-V1: results Variable
**Type:** Vec<ValidationResult>
**Initialization:** Vec::new()
**Scope:** Accumulates gate results
**Purpose:** Collect validation outcomes

#### IM-4010-V2: applicable_gates Variable
**Type:** Vec<&Box<dyn QualityGate>>
**Initialization:** self.get_applicable_gates(&gate_types)
**Scope:** Filtered gates to run
**Purpose:** Execute only requested gates

#### IM-4010-V3: overall_score Variable
**Type:** f64
**Initialization:** self.calculate_quality_score(&results)
**Scope:** Aggregate quality metric
**Purpose:** Overall validation score

##### Branch-Level Inventory

#### IM-4010-B1: Empty Text Check
**Condition:** `text.is_empty()`
**True Path:** Return IM-4010-E1
**False Path:** Continue to gate filtering

#### IM-4010-B2: Empty Gates Check
**Condition:** `gate_types.is_empty()`
**True Path:** Return IM-4010-E2
**False Path:** Continue to gate execution

#### IM-4010-B3: Gate Execution Loop
**Condition:** For each gate in applicable_gates
**Iterations:** Variable (1-6 typical)
**Branch:** Execute gate.validate(text)

#### IM-4010-B4: All Gates Passed Check
**Condition:** `results.iter().all(|r| r.passed)`
**True Path:** Return Ok with overall_score
**False Path:** Return validation result with failures

##### Error-Path Inventory

#### IM-4010-E1: Empty Text Error
**Trigger:** text.is_empty()
**Error Type:** ValidationError
**Message:** "Cannot validate empty text"

#### IM-4010-E2: No Gates Specified Error
**Trigger:** gate_types.is_empty()
**Error Type:** ValidationError
**Message:** "No quality gates specified for validation"

#### IM-4011: QualityGateValidator::calculate_quality_score()
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Method
**Dependencies:** DT-018
**L3 Reference:** L3-CDD-04 Section 4.3

#### IM-4012: QualityGateValidator::get_applicable_gates()
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-04 Section 4.3

#### IM-4013: QualityGateValidator::metrics()
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-04 Section 4.3

#### IM-4100: NoGenericTextGate Struct
**Location:** `src-tauri/src/quality/gates/no_generic_text.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.1

#### IM-4110: CoverageQuantificationGate Struct
**Location:** `src-tauri/src/quality/gates/coverage_quantification.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.2

#### IM-4120: RoiPresentGate Struct
**Location:** `src-tauri/src/quality/gates/roi_present.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.3

#### IM-4130: CaseStudyPresentGate Struct
**Location:** `src-tauri/src/quality/gates/case_study_present.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.4

#### IM-4140: ContactValidationGate Struct
**Location:** `src-tauri/src/quality/gates/contact_validation.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.5

#### IM-4150: MarkdownFormatGate Struct
**Location:** `src-tauri/src/quality/gates/markdown_format.rs`
**Type:** Rust struct implementing QualityGate trait
**L3 Reference:** L3-CDD-04 Section 6.6

#### IM-4200: QualityGate Trait
**Location:** `src-tauri/src/quality/gates/mod.rs`
**Type:** Rust async trait
**L3 Reference:** L3-CDD-04 Section 5.1

#### IM-4300: ValidationResult Struct
**Location:** `src-tauri/src/quality/types.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-04 Section 3.1

##### Field-Level Inventory

#### IM-4300-F1: passed Field
**Type:** bool
**Mutability:** Immutable
**Purpose:** Overall pass/fail status
**Dependencies:** None

#### IM-4300-F2: score Field
**Type:** f64
**Mutability:** Immutable
**Purpose:** Quality score (0.0-1.0)
**Dependencies:** DT-018

#### IM-4300-F3: failures Field
**Type:** Vec<ValidationFailure>
**Mutability:** Immutable
**Purpose:** List of failed validations
**Dependencies:** IM-4301

#### IM-4301: ValidationFailure Struct
**Location:** `src-tauri/src/quality/types.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-04 Section 3.1

##### Field-Level Inventory

#### IM-4301-F1: gate_name Field
**Type:** String
**Mutability:** Immutable
**Purpose:** Identifying which gate failed
**Dependencies:** None

#### IM-4301-F2: severity Field
**Type:** GateSeverity
**Mutability:** Immutable
**Purpose:** Criticality of failure
**Dependencies:** IM-4302

#### IM-4301-F3: message Field
**Type:** String
**Mutability:** Immutable
**Purpose:** Human-readable failure reason
**Dependencies:** None

#### IM-4302: GateSeverity Enum
**Location:** `src-tauri/src/quality/types.rs`
**Type:** Rust enum
**L3 Reference:** L3-CDD-04 Section 3.1

##### Variant-Level Inventory

#### IM-4302-V1: Critical Variant
**Purpose:** Must-fix blocking issues
**Example:** Missing required contact information

#### IM-4302-V2: Warning Variant
**Purpose:** Non-blocking quality issues
**Example:** Markdown formatting inconsistencies

#### IM-4302-V3: Info Variant
**Purpose:** Informational suggestions
**Example:** Could include more quantification

### 4.5 StateManager (5000-5999)

#### IM-5001: StateManager Struct
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Rust struct
**Dependencies:** IP-027 (SQLite connection)
**L3 Reference:** L3-CDD-05 Section 5.1

##### Field-Level Inventory

#### IM-5001-F1: connection Field
**Type:** Arc<Mutex<Connection>>
**Mutability:** Immutable (connection wrapped in Arc<Mutex>)
**Purpose:** SQLite database connection
**Dependencies:** IP-027

#### IM-5001-F2: db_path Field
**Type:** PathBuf
**Mutability:** Immutable after construction
**Purpose:** Path to SQLite database file
**Dependencies:** None

#### IM-5001-F3: cache Field
**Type:** Option<HashMap<String, Value>>
**Mutability:** Mutable (cache updates on reads)
**Purpose:** In-memory cache for frequent reads
**Dependencies:** None

#### IM-5002: StateManager::new()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Constructor
**Dependencies:** IM-5003
**L3 Reference:** L3-CDD-05 Section 5.2

##### Parameter-Level Inventory

#### IM-5002-P1: db_path Parameter
**Type:** &str
**Validation:** Must be non-empty, valid path
**Error Paths:** IM-5002-E1, IM-5002-E2

##### Variable-Level Inventory

#### IM-5002-V1: connection Variable
**Type:** Connection
**Initialization:** Connection::open(db_path)
**Scope:** SQLite connection
**Purpose:** Database handle

#### IM-5002-V2: wrapped_connection Variable
**Type:** Arc<Mutex<Connection>>
**Initialization:** Arc::new(Mutex::new(connection))
**Scope:** Thread-safe connection wrapper
**Purpose:** Enable concurrent access

##### Branch-Level Inventory

#### IM-5002-B1: Empty Path Check
**Condition:** `db_path.is_empty()`
**True Path:** Return IM-5002-E1
**False Path:** Continue to connection open

#### IM-5002-B2: Connection Open Success
**Condition:** `Connection::open(db_path)`
**Success Path:** Run migrations (IM-5003)
**Error Path:** Return IM-5002-E2

#### IM-5002-B3: Migrations Success
**Condition:** `self.run_migrations()`
**Success Path:** Return Ok(StateManager)
**Error Path:** Return IM-5002-E3

##### Error-Path Inventory

#### IM-5002-E1: Empty Path Error
**Trigger:** db_path.is_empty()
**Error Type:** ValidationError
**Message:** "Database path cannot be empty"

#### IM-5002-E2: Connection Failed Error
**Trigger:** Connection::open() returns Err
**Error Type:** DatabaseError
**Message:** "Failed to open SQLite database at '{db_path}': {sqlite_error}"

#### IM-5002-E3: Migration Failed Error
**Trigger:** run_migrations() returns Err
**Error Type:** DatabaseError
**Message:** "Database migration failed: {migration_error}"

#### IM-5003: StateManager::run_migrations()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-05 Section 5.2

#### IM-5020: StateManager::create_session()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-019
**L3 Reference:** L3-CDD-05 Section 5.3

##### Parameter-Level Inventory

#### IM-5020-P1: company Parameter
**Type:** &str
**Validation:** Must be non-empty
**Error Paths:** IM-5020-E1

##### Variable-Level Inventory

#### IM-5020-V1: session_id Variable
**Type:** String
**Initialization:** Uuid::new_v4().to_string()
**Scope:** Unique session identifier
**Purpose:** Primary key for sessions table

#### IM-5020-V2: timestamp Variable
**Type:** i64
**Initialization:** SystemTime::now().duration_since(UNIX_EPOCH)
**Scope:** Current time in seconds
**Purpose:** Record session creation time

##### Branch-Level Inventory

#### IM-5020-B1: Empty Company Check
**Condition:** `company.is_empty()`
**True Path:** Return IM-5020-E1
**False Path:** Continue to session creation

#### IM-5020-B2: Database Insert Success
**Condition:** `INSERT INTO sessions (id, company, created_at, status)`
**Success Path:** Return Ok(session_id)
**Error Path:** Return IM-5020-E2

##### Error-Path Inventory

#### IM-5020-E1: Empty Company Error
**Trigger:** company.is_empty()
**Error Type:** ValidationError
**Message:** "Company name cannot be empty"

#### IM-5020-E2: Database Insert Error
**Trigger:** INSERT statement fails
**Error Type:** DatabaseError
**Message:** "Failed to create session: {sqlite_error}"

#### IM-5021: StateManager::update_session_status()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-020, DT-020
**L3 Reference:** L3-CDD-05 Section 5.3

#### IM-5022: StateManager::save_markdown_output()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-05 Section 5.3

#### IM-5015: StateManager::get_session()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-05 Section 5.3

#### IM-5010: StateManager::get_session_history()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-024
**L3 Reference:** L3-CDD-05 Section 5.3

#### IM-5030: StateManager::save_phase_completion()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-021, DT-006
**L3 Reference:** L3-CDD-05 Section 5.4

#### IM-5031: StateManager::get_completed_phases()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-05 Section 5.4

#### IM-5032: StateManager::is_phase_completed()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**L3 Reference:** L3-CDD-05 Section 5.4

#### IM-5040: StateManager::save_context()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-022, DT-007
**L3 Reference:** L3-CDD-05 Section 5.5

#### IM-5041: StateManager::load_context()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IP-023
**L3 Reference:** L3-CDD-05 Section 5.5

#### IM-5042: StateManager::resume_session()
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Method
**Dependencies:** IM-5041
**L3 Reference:** L3-CDD-05 Section 5.5

#### IM-5100: Session Struct
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-05 Section 3.1

#### IM-5101: PhaseCompletion Struct
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-05 Section 3.1

#### IM-5102: SessionSummary Struct
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-05 Section 3.1

#### IM-5103: WorkflowContext Struct
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust struct
**L3 Reference:** L3-CDD-05 Section 3.1

#### IM-5104: SessionStatus Enum
**Location:** `src-tauri/src/state/models.rs`
**Type:** Rust enum
**Dependencies:** DT-020
**L3 Reference:** L3-CDD-05 Section 3.1

### 4.6 Frontend Components (6000-6999)

#### IM-6001: App Component
**Location:** `src/App.tsx`
**Type:** React component
**L3 Reference:** L3-CDD-06 Section 7.1

#### IM-6010: SetupScreen Component
**Location:** `src/components/SetupScreen.tsx`
**Type:** React component
**Dependencies:** IM-6100 (useTauriInvoke), IP-001
**L3 Reference:** L3-CDD-06 Section 5.1

#### IM-6020: ProgressScreen Component
**Location:** `src/components/ProgressScreen.tsx`
**Type:** React component
**Dependencies:** IM-6101 (useTauriEvent), IP-007 through IP-013
**L3 Reference:** L3-CDD-06 Section 5.2

#### IM-6030: ResultsViewer Component
**Location:** `src/components/ResultsViewer.tsx`
**Type:** React component
**Dependencies:** IP-003, IP-004, IP-005
**L3 Reference:** L3-CDD-06 Section 5.3

#### IM-6040: SessionHistory Component
**Location:** `src/components/SessionHistory.tsx`
**Type:** React component
**Dependencies:** IP-002
**L3 Reference:** L3-CDD-06 Section 5.4

#### IM-6050: SettingsPanel Component
**Location:** `src/components/SettingsPanel.tsx`
**Type:** React component
**Dependencies:** IP-006, IM-6102 (useLocalStorage)
**L3 Reference:** L3-CDD-06 Section 5.5

#### IM-6100: useTauriInvoke Hook
**Location:** `src/hooks/useTauriInvoke.ts`
**Type:** Custom React hook
**L3 Reference:** L3-CDD-06 Section 4.1

#### IM-6101: useTauriEvent Hook
**Location:** `src/hooks/useTauriEvent.ts`
**Type:** Custom React hook
**L3 Reference:** L3-CDD-06 Section 4.2

#### IM-6102: useLocalStorage Hook
**Location:** `src/hooks/useLocalStorage.ts`
**Type:** Custom React hook
**L3 Reference:** L3-CDD-06 Section 4.3

#### IM-6200: Button Component
**Location:** `src/components/shared/Button.tsx`
**Type:** Reusable React component
**L3 Reference:** L3-CDD-06 Section 6.1

#### IM-6201: Input Component
**Location:** `src/components/shared/Input.tsx`
**Type:** Reusable React component
**L3 Reference:** L3-CDD-06 Section 6.2

#### IM-6202: Card Component
**Location:** `src/components/shared/Card.tsx`
**Type:** Reusable React component
**L3 Reference:** L3-CDD-06 Section 5.1

#### IM-6203: ProgressBar Component
**Location:** `src/components/shared/ProgressBar.tsx`
**Type:** Reusable React component
**L3 Reference:** L3-CDD-06 Section 6.3

#### IM-6300: ResearchResult Type
**Location:** `src/types/tauri.ts`
**Type:** TypeScript interface
**Dependencies:** DT-005
**L3 Reference:** L3-CDD-06 Section 3.1

#### IM-6301: SessionSummary Type
**Location:** `src/types/tauri.ts`
**Type:** TypeScript interface
**L3 Reference:** L3-CDD-06 Section 3.1

#### IM-6302: WorkflowState Type
**Location:** `src/types/workflow.ts`
**Type:** TypeScript interface
**L3 Reference:** L3-CDD-06 Section 3.2

#### IM-6303: PhaseInfo Type
**Location:** `src/types/workflow.ts`
**Type:** TypeScript interface
**L3 Reference:** L3-CDD-06 Section 3.2

---

## 5. Test Inventory (7000-7999)

### 5.1 Backend Unit Tests

#### IM-7001: test_provider_detection
**Location:** `src-tauri/src/llm/mod.rs`
**Type:** Unit test
**Tests:** IM-3013 (detect_provider)
**L3 Reference:** L3-CDD-03 Section 10.1

#### IM-7002: test_cost_calculation
**Location:** `src-tauri/src/llm/cost.rs`
**Type:** Unit test
**Tests:** IM-3200 (calculate_cost)
**L3 Reference:** L3-CDD-03 Section 10.1

#### IM-7003: test_retry_logic
**Location:** `src-tauri/src/llm/retry.rs`
**Type:** Unit test
**Tests:** IM-3300 (with_exponential_backoff)
**L3 Reference:** L3-CDD-03 Section 10.1

#### IM-7010: test_no_generic_text_gate
**Location:** `src-tauri/src/quality/gates/no_generic_text.rs`
**Type:** Unit test
**Tests:** IM-4100
**L3 Reference:** L3-CDD-04 Section 8.1

#### IM-7011: test_roi_gate
**Location:** `src-tauri/src/quality/gates/roi_present.rs`
**Type:** Unit test
**Tests:** IM-4120
**L3 Reference:** L3-CDD-04 Section 8.1

#### IM-7012: test_validator_quality_score
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Unit test
**Tests:** IM-4011 (calculate_quality_score)
**L3 Reference:** L3-CDD-04 Section 8.1

#### IM-7020: test_create_and_retrieve_session
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Unit test
**Tests:** IM-5020, IM-5015
**L3 Reference:** L3-CDD-05 Section 7.1

#### IM-7021: test_phase_completion_tracking
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Unit test
**Tests:** IM-5030, IM-5032
**L3 Reference:** L3-CDD-05 Section 7.1

#### IM-7022: test_context_save_and_resume
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Unit test
**Tests:** IM-5040, IM-5041
**L3 Reference:** L3-CDD-05 Section 7.1

#### IM-7023: test_cost_accumulation
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Unit test
**Tests:** IM-5030 (cost accumulation logic)
**L3 Reference:** L3-CDD-05 Section 7.1

### 5.2 Backend Integration Tests

#### IM-7100: test_anthropic_generate
**Location:** `src-tauri/src/llm/providers/anthropic.rs`
**Type:** Integration test (with mocked HTTP)
**Tests:** IP-014, IM-3100
**L3 Reference:** L3-CDD-03 Section 10.2

#### IM-7110: test_full_validation_workflow
**Location:** `src-tauri/src/quality/mod.rs`
**Type:** Integration test
**Tests:** IM-4010 with all gates
**L3 Reference:** L3-CDD-04 Section 8.2

#### IM-7120: test_crash_recovery_workflow
**Location:** `src-tauri/src/state/mod.rs`
**Type:** Integration test
**Tests:** IM-5042 (resume_session)
**L3 Reference:** L3-CDD-05 Section 7.2

### 5.3 Frontend Component Tests

#### IM-7200: test_setup_screen_validation
**Location:** `src/components/__tests__/SetupScreen.test.tsx`
**Type:** Component test (Vitest + React Testing Library)
**Tests:** IM-6010, DT-001
**L3 Reference:** L3-CDD-06 Section 11.1

#### IM-7201: test_setup_screen_submit
**Location:** `src/components/__tests__/SetupScreen.test.tsx`
**Type:** Component test
**Tests:** IM-6010, IP-001
**L3 Reference:** L3-CDD-06 Section 11.1

---

## 6. Traceability Matrix

### 6.1 Requirements → Implementation

| L0 Requirement | L1 Requirement | L2 Interface | L3 Component | L4 Implementation |
|---------------|---------------|--------------|--------------|-------------------|
| SR-001 (Time < 5 min) | REQ-SYS-001 | ICD-01 run_research | CDD-01 AgentOrchestrator | IM-2010 run_workflow() |
| SR-002 (Quality gates) | REQ-SYS-003 | ICD-03 validate() | CDD-04 QualityGates | IM-4010 validate() |
| SR-003 (Cost < $0.10) | MO-003 | ICD-03 LLMClient | CDD-03 LLMClient | IM-3200 calculate_cost() |
| SR-004 (Progressive UI) | REQ-SYS-006 | ICD-01 Events | CDD-06 Frontend | IM-6010, IM-6020, IM-6030 |
| SR-005 (Export) | REQ-SYS-007 | ICD-01 export_to_pdf | CDD-06 ResultsViewer | IP-004, IM-6030 |
| SR-006 (Desktop app) | REQ-SYS-006 | ICD-01 Tauri | CDD-06 Frontend | IM-6001 App.tsx |
| SR-007 (API security) | NFR-006 | ICD-01 save_api_keys | CDD-05 StateManager | IP-006 |
| SR-008 (Multi-LLM) | REQ-SYS-002 | ICD-03 LLMClient | CDD-03 Providers | IM-3100, IM-3110, IM-3120 |
| SR-009 (Crash recovery) | REQ-SYS-005 | ICD-03 StateManager | CDD-05 StateManager | IM-5042 resume_session() |
| SR-010 (Offline mode) | REQ-SYS-004 | ICD-03 StateManager | CDD-05 SQLite | IP-027 |

### 6.2 Integration Points → Components

| Integration Point | Source Component | Target Component | Data Transformation |
|------------------|------------------|------------------|---------------------|
| IP-001 (run_research) | IM-6010 SetupScreen | IM-2010 run_workflow | DT-001 company validation |
| IP-014 (Anthropic API) | IM-3100 AnthropicProvider | External API | DT-004 LLMRequest serialization |
| IP-019 (Create session) | IM-5020 create_session | SQLite database | None (direct SQL) |
| IP-007 (workflow_started) | IM-2020 emit_progress | IM-6020 ProgressScreen | None (event payload) |

### 6.3 Data Transformations → Functions

| Data Transformation | Input Type | Output Type | Implementation |
|--------------------|-----------|-------------|----------------|
| DT-001 | String (raw) | String (validated) | Frontend + IP-001 |
| DT-004 | LLMRequest struct | JSON | serde_json::to_string() |
| DT-009 | String (JSON) | CompanyProfile | serde_json::from_str() |
| DT-015 | (tokens, model) | f64 (USD) | IM-3200 calculate_cost() |
| DT-017 | String (output) | ValidationResult | IM-4010 validate() |
| DT-020 | SessionStatus enum | String | match expression |

---

## 7. Implementation Completeness Checklist

### 7.1 Backend Components
- [ ] IM-1001 through IM-1104: Core types and manifest parser
- [ ] IM-2001 through IM-2200: AgentOrchestrator + ToolRegistry
- [ ] IM-3001 through IM-3400: LLMClient + Providers
- [ ] IM-4001 through IM-4302: QualityGates + Gates
- [ ] IM-5001 through IM-5104: StateManager + Models

### 7.2 Frontend Components
- [ ] IM-6001 through IM-6050: Main UI components
- [ ] IM-6100 through IM-6102: Custom hooks
- [ ] IM-6200 through IM-6203: Shared components
- [ ] IM-6300 through IM-6303: TypeScript types

### 7.3 Integration Points
- [ ] IP-001 through IP-006: Tauri commands
- [ ] IP-007 through IP-013: Event emissions
- [ ] IP-014 through IP-018: External APIs
- [ ] IP-019 through IP-024: Database queries
- [ ] IP-025 through IP-027: File system

### 7.4 Data Transformations
- [ ] DT-001 through DT-003: Input validation
- [ ] DT-004 through DT-008: Serialization
- [ ] DT-009 through DT-020: Business logic

### 7.5 Tests
- [ ] IM-7001 through IM-7023: Backend unit tests
- [ ] IM-7100 through IM-7120: Backend integration tests
- [ ] IM-7200 through IM-7201: Frontend component tests

---

**Document Status:** Complete - Ready for PHASE 7: TESTING PLAN
**Next Phase:** Create comprehensive test specifications derived from this manifest
**Taxonomy Coverage:** 27 IP codes, 20 DT codes, 100+ IM codes
