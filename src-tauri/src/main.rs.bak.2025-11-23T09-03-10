// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod agent;
mod llm;
mod manifest;

use agent::Agent;
use manifest::Manifest;
use std::fs;
use std::path::PathBuf;
use std::sync::Mutex;
use tauri::{Manager, State, Window};
use serde::{Serialize, Deserialize};

// ------------------------------------------------------------------
// 1. Persistent Configuration Structs
// ------------------------------------------------------------------
// We define a config struct to save to disk (app_data/config.json)
// This ensures your API Key and Settings persist across restarts.
#[derive(Debug, Serialize, Deserialize, Clone)]
struct AppConfig {
    api_key: Option<String>,
    last_manifest_path: Option<PathBuf>,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            api_key: None,
            // Default path relative to where the app is run (dev mode)
            // In production, you'd likely bundle this differently.
            last_manifest_path: Some(PathBuf::from("../manifests/fullintel_process_manifest.yaml")),
        }
    }
}

// ------------------------------------------------------------------
// 2. Runtime Application State
// ------------------------------------------------------------------
struct AppState {
    config: Mutex<AppConfig>,
    config_path: PathBuf,
}

impl AppState {
    // Helper to save current config state to disk
    fn save(&self) -> Result<(), String> {
        let config = self.config.lock().map_err(|e| e.to_string())?;
        let json = serde_json::to_string_pretty(&*config).map_err(|e| e.to_string())?;
        
        // Ensure directory exists before writing
        if let Some(parent) = self.config_path.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent).map_err(|e| e.to_string())?;
            }
        }

        fs::write(&self.config_path, json).map_err(|e| e.to_string())?;
        Ok(())
    }
}

// ------------------------------------------------------------------
// 3. Tauri Commands (Frontend Callable)
// ------------------------------------------------------------------

#[tauri::command]
async fn set_api_key(key: String, state: State<'_, AppState>) -> Result<(), String> {
    // 1. Update Memory
    {
        let mut config = state.config.lock().map_err(|_| "Failed to lock state")?;
        config.api_key = Some(key);
    }
    
    // 2. Persist to Disk
    state.save()?;
    
    Ok(())
}

#[tauri::command]
async fn get_app_state(state: State<'_, AppState>) -> Result<AppConfig, String> {
    let config = state.config.lock().map_err(|_| "Failed to lock state")?;
    Ok(config.clone())
}

#[tauri::command]
async fn run_research(
    company: String, 
    window: Window, 
    state: State<'_, AppState>
) -> Result<String, String> {
    
    // 1. Retrieve Credentials from State
    let (api_key, manifest_path) = {
        let config = state.config.lock().map_err(|_| "Failed to lock state")?;
        let key = config.api_key.clone().ok_or("API Key not set. Please configure in settings.")?;
        let path = config.last_manifest_path.clone().ok_or("Manifest path not found.")?;
        (key, path)
    };

    // 2. Load Manifest (The Brain)
    // We check if the file exists before attempting to load
    if !manifest_path.exists() {
        return Err(format!("Manifest not found at: {:?}", manifest_path));
    }
    let manifest = Manifest::load_from_file(&manifest_path).map_err(|e| e.to_string())?;
    
    // 3. Initialize Agent with Window Emitter
    // The window is passed here so the Agent can emit "agent-log" and "phase-update" events
    let mut agent = Agent::new(manifest, api_key, Some(window));

    // 4. Execute Workflow (The Heavy Lifting)
    // This runs the phases defined in the YAML
    agent.run_workflow(&company).await.map_err(|e| e.to_string())?;

    // 5. Retrieve Final Artifact
    // We pull the generated markdown from the agent's context blackboard
    // The key "markdown_file" must match the `output_format` or target defined in your manifest Phase 5
    let final_artifact = agent.state.context.get("markdown_file")
        .cloned()
        .unwrap_or_else(|| "Workflow completed, but no final artifact found in context.".to_string());

    Ok(final_artifact)
}

// ------------------------------------------------------------------
// 4. Main Entry Point & Setup
// ------------------------------------------------------------------

fn main() {
    tauri::Builder::default()
        .setup(|app| {
            // A. Resolve Config Path
            // This stores config in standard OS app data locations
            // e.g., C:\Users\You\AppData\Roaming\com.fullintel.agent\config.json
            let app_dir = app.path().app_data_dir().expect("failed to get app data dir");
            if !app_dir.exists() {
                fs::create_dir_all(&app_dir).expect("failed to create app data dir");
            }
            let config_path = app_dir.join("config.json");

            // B. Load or Create Config
            let config = if config_path.exists() {
                let content = fs::read_to_string(&config_path).unwrap_or_default();
                serde_json::from_str(&content).unwrap_or_default()
            } else {
                AppConfig::default()
            };

            // C. Manage State (Inject into Tauri)
            app.manage(AppState {
                config: Mutex::new(config),
                config_path,
            });

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            set_api_key,
            get_app_state,
            run_research
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}